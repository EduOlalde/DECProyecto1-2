Informe de decisiones de desarrollo y desafíos encontrados

Decisiones de Diseño
 - Modularidad en el Código
	Se optó por un diseño modular para facilitar el mantenimiento y la escalabilidad. Todas las funciones
	relacionadas con la manipulación del DOM están centralizadas en el objeto IU, lo que reduce la repetición
	de código y facilita los cambios en la interfaz.

- Validación del Usuario
	Se implementó un sistema de validación para garantizar que el nombre de usuario sea apropiado, evitando
	entradas vacías o con números. 

- Interfaz Dinámica
	El tablero de 10x10 se genera dinámicamente usando la función crearTabla. Esto permite modificar fácilmente
	el tamaño del tablero sin cambiar el diseño del HTML.
	Los gráficos del héroe y del objetivo se colocan automáticamente en posiciones predeterminadas, asegurando
	consistencia en la experiencia de juego.

- Lógica de Juego
	La mecánica del juego utiliza un dado virtual y un sistema de celdas resaltadas para guiar al jugador, lo
	que añade elementos visuales y de interacción.
	Se añadió un sistema de registro de puntuaciones con almacenamiento local (localStorage), promoviendo la
	rejugabilidad al permitir a los usuarios comparar sus resultados.

- Interacción y Flujo de Usuario
	El flujo del juego está diseñado para ser intuitivo: desde el inicio del juego (pantalla de login), pasando
	por las tiradas del dado, hasta la detección de victoria y el reinicio del juego.
	Se proporciona retroalimentación constante al usuario mediante mensajes en pantalla y cambios visuales en
	las celdas disponibles.


Desafíos Encontrados
- Gestión de Elementos Devueltos por getElementsByClassName():
	Desafío: El método getElementsByClassName() devuelve una colección de elementos en vivo, lo que significa
	que si se modifica el DOM, la colección también se actualiza. Esto puede ser problemático cuando se necesita
	realizar una manipulación de estos elementos de manera controlada.

	Solución: Para solucionar este problema, se creó un array a partir de los elementos devueltos por
	getElementsByClassName(). De esta manera, se obtuvo una copia estática de los elementos en ese momento,
	evitando modificaciones no deseadas mientras se procesaban los elementos del DOM. Esta solución facilitó la
	manipulación de los elementos sin preocuparse por cambios dinámicos en la colección durante la ejecución del juego.

- Gestión de Eventos en el DOM
	Durante el desarrollo, surgieron problemas relacionados con la duplicación de eventos al mover el héroe entre celdas.
	Esto se solucionó limpiando los eventos anteriores con removeEventListener.

- Resaltado de Celdas Disponibles
	El desafío al desarrollar resaltarCeldas() fue la optimización del algoritmo que itera sobre las celdas. El algoritmo
	inicial era ineficiente, iterando separadamente sobre cada una de las cuatro direcciones. Se ideó un array donde cada 
	elemento permite modificar la instrucción de iteración automáticamente para seleccionar las celdas necesarias,
	descartando las celdas no existentes con facilidad.


Aprendizajes y Mejoras Futuras
- La modularidad del diseño facilitó la implementación de nuevas funcionalidades, como el botón de reinicio. Este enfoque
	será clave en futuros proyectos.
- Se podría mejorar la accesibilidad del juego mediante la adición de soporte para teclado y lectores de pantalla.
- Una posible mejora sería permitir al usuario personalizar el tamaño del tablero. Sería una mejora de fácil implementación
	debido al diseño modular del código.